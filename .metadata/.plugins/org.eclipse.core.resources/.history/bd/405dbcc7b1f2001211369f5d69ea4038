/*
 * Drop.cpp
 *
 *  Created on: Jul 11, 2013
 *      Author: oek
 */

#include "Puro.h"
#include "Buffer.h"
#include "Drop.h"
#include "Passage.h"
#include "MainFrame.h"

Drop::Drop(MainFrame *instance, uint32_t buffer_size) {
	// TODO Auto-generated constructor stub

	std::cout << "Drop" << std::endl;
	instance_ = instance;
	idea_ = 0;
	material_ = 0;
	envelope_ = new Buffer(buffer_size);
	audio_ = new Buffer(buffer_size);
}

Drop::~Drop() {
	delete audio_;
	delete envelope_;
}

void
Drop::Initialize(Tag idea, Tag material) {
	idea_ = idea;
	material_ = material;
	audio_->SetSize(0);
	envelope_->SetSize(0);
}


int32_t
Drop::ProcessAudio(Passage* audio) {
	std::cout << "Prepare drop" << std::endl;
	// [0] 14000 2250 16250 linear
	// [0] 14000 2250 15125 half-time
	// [0] 14000 2250 11750 inverse

	instance_GetAudioSize(material_);

	if (audio->GetSize() < 2)
		return 0; // kill-signal

	// GET MATERIAL
	float* material_data = instance_->GetAudioData(material_);
	std::cout << "Got material data" << std::endl;
	if (material_data == 0)
		return 0; // kill-signal
	uint32_t material_size = instance_->GetAudioSize(material_);

	// RESIZE BUFFER
	float t0 = audio->GetTime(0);
	float t1 = audio->GetTime(audio->GetSize()-1);
	uint32_t duration = (uint32_t)(GetMaterialSampleRate()*(t1-t0)); // this is absolute
	audio_->SetSize(duration);

	/////////////////////////////////////////////////
	// INSERT SPLITTING FUNCTIONALITY HERE!
	/////////////////////////////////////////////////

	// FILL BUFFER SEGMENT AT A TIME
	for (uint16_t i=1; i < audio->GetSize(); i++) {

		uint32_t fx = audio->GetTime(i-1) * GetMaterialSampleRate();
		uint32_t tx = audio->GetTime(i) * GetMaterialSampleRate();
		float fy = audio->GetValue(i-1);
		float ty = audio->GetValue(i);
		uint32_t x = fx;

		// GET SAMPLE POINTS FOR THE SEGMENT
		while (x<tx) {
			uint32_t index = fy + (float)(x-fx)/(float)(tx-fx) * (ty-fy);
			if (index < material_size)
				audio_->SetValue(index, material_data[x]); // INTERPOLATE HERE
			else
				audio_->SetValue(index, 0.f);
			x++;
		}
	}
	return 1;
}

int32_t
Drop::ProcessEnvelope(Passage* envelope) {
	// [0] 0.25 0.75 0.5 1.0 0.75 0.75 1.0 0.0

	if (envelope->GetSize() < 2)
		return 0; // kill-signal

	// FILL BUFFER SEGMENT AT A TIME
	for (uint16_t i=1; i < envelope->GetSize(); i++) {

		uint32_t fx = envelope->GetTime(i-1) * GetDurationInSamples();
		uint32_t tx = envelope->GetTime(i) * GetDurationInSamples();
		float fy = envelope->GetValue(i-1);
		float ty = envelope->GetValue(i);
		uint32_t x = fx;

		// GET ENVELOPE POINTS FOR THE SEGMENT
		while (x<tx) {
			float f = fy + (float)(x-fx)/(float)(tx-fx) * (ty-fy);
			envelope_->SetValue(x, f);
			x++;
		}
		// if the list is not properly formed to have 100% as the last time
		while (x < GetDurationInSamples()) {
			envelope_->SetValue(x, 0.f); // DEBUG WELL, NO LEAK HERE
			x++;
		}
	}
	return 0;
}

uint32_t
Drop::GetMaterialSampleRate() {
	return instance_->GetMaterialSampleRate(material_);
}

uint32_t
Drop::GetDurationInSamples() {
	return audio_->GetSize();
}

/**
 * Caller is in charge of taking care, that the buffer has enough space and that
 * it has been initialized.
 * Caller should take care that correct index is given.
 */
uint32_t
Drop::GetAudio(uint32_t index, uint32_t n, float* buffer) {
	uint32_t last = index + n - 1;
	if (last > GetDurationInSamples())
		n = n - last + GetDurationInSamples();

	for (uint32_t i=0; i<n; i++, index++) {
		buffer[i] += audio_->GetValue(index + i);
	}
	return n;
}
